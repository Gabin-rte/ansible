# Copyright (C) 2024 RTE
# SPDX-License-Identifier: Apache-2.0

---
- name: List all VMs
  virt:
    command: list_vms
  register: all_vms

- name: Export VM config in /tmp
  template:
    src: "{{ hostvars[item].vm_template }}"
    dest: "/tmp/{{ hostvars[item].inventory_hostname }}.xml"
  loop: "{{ groups['VMs'] }}"

- name: Parse the VM name from the XML configuration for each VM
  xml:
    path: "/tmp/{{ hostvars[item].inventory_hostname }}.xml"
    xpath: "/domain/name"
    content: text
  register: vm_name_result
  loop: "{{ groups['VMs'] }}"

- name: Filter vm_name_result to get host <> vm_name mapping
  set_fact:
    host_to_vm_name_map: >
      {{
        vm_name_result.results | map(attribute='item') | zip(
        vm_name_result.results | map(attribute='matches') | map('first')) |
        map('list')
      }}

- name: Stop VM
  virt:
    name: "{{ item[1].name }}"
    state: destroyed
  when:
    - item[1].name in all_vms.list_vms
    - hostvars[item[0]].force is defined
    - hostvars[item[0]].force
  loop: "{{ host_to_vm_name_map }}"

- name: Undefine VM
  command: "virsh undefine --nvram {{ item[1].name }}"
  when:
    - item[1].name in all_vms.list_vms
    - hostvars[item[0]].force is defined
    - hostvars[item[0]].force
  loop: "{{ host_to_vm_name_map }}"

- name: Print info
  debug:
    var: hostvars[item]
    verbosity: 2
  loop: "{{ groups['VMs'] }}"

- name: Check tmp folder permission
  file:
    path: "{{ qcow2tmpuploadfolder }}"
    state: directory
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: '0755'
  when: qcow2tmpuploadfolder is defined

- name: Copy the disk on target
  copy:
    src: "{{ hostvars[item].vm_disk }}"
    dest: "{{ disk_pool }}/{{ hostvars[item].inventory_hostname }}.qcow2"
  vars:
    ansible_remote_tmp: "{{ qcow2tmpuploadfolder | default(omit) }}"
  when:
    - disk_copy | bool
    - hostvars[item].disk_extract is not defined or not hostvars[item].disk_extract | bool
    - item not in all_vms.list_vms or (item in all_vms.list_vms and hostvars[item].force is defined and hostvars[item].force)
  loop: "{{ groups['VMs'] }}"

- name: Copy the gzipped disk on target
  copy:
    src: "{{ hostvars[item].vm_disk }}"
    dest: "{{ disk_pool }}/{{ hostvars[item].inventory_hostname }}.img.gz"
  when:
    - disk_copy | bool
    - hostvars[item].disk_extract is defined
    - hostvars[item].disk_extract | bool
    - item not in all_vms.list_vms or (item in all_vms.list_vms and hostvars[item].force is defined and hostvars[item].force)
  loop: "{{ groups['VMs'] }}"

- name: Extract the gzipped disk on target
  command:
    cmd: "gzip -d -f {{ disk_pool }}/{{ hostvars[item].inventory_hostname }}.img.gz"
    creates: "{{ hostvars[item].inventory_hostname }}.img"
  when:
    - disk_copy | bool
    - hostvars[item].disk_extract is defined
    - hostvars[item].disk_extract | bool
    - item not in all_vms.list_vms or (item in all_vms.list_vms and hostvars[item].force is defined and hostvars[item].force)
  loop: "{{ groups['VMs'] }}"

- name: Add main disk to disk list
  # This is only done in standalone because the disk is handled by vm-manager in the cluster
  set_fact:
    standalone_main_disk: "{{ hostvars[item].inventory_hostname }}.qcow2"
  delegate_to: "{{ item }}"
  delegate_facts: true
  loop: "{{ groups['VMs'] }}"
  when: item not in all_vms.list_vms or (item in all_vms.list_vms and hostvars[item].force is defined and hostvars[item].force)

- name: Create VMs
  virt:
    command: define
    xml: >-
      {{ lookup('template',
      hostvars[item].vm_template,
      template_vars=dict(vm=hostvars[item])) }}
  loop: "{{ groups['VMs'] }}"
  when: item not in all_vms.list_vms or (item in all_vms.list_vms and hostvars[item].force is defined and hostvars[item].force)

- name: Start VMs
  virt:
    name: "{{ item[1].name }}"
    state: running
  loop: "{{ host_to_vm_name_map }}"
  when: hostvars[item[0]].enable | default(true)
